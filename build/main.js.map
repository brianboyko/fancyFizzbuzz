{"version":3,"sources":["constants.js","processInput.js","fizzbuzz.js","index.js"],"names":[],"mappings":"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","file":"main.js","sourcesContent":["const VERSION = 'v1.0.0';\n\nconst HELP_TEXT = 'Help Text Goes Here'\n\nconst NO_ARGS = 'No Arguments from Command Line'\n\nexport {\n  VERSION,\n  HELP_TEXT,\n  NO_ARGS\n}","// considered using optimist but it was a bit overkill. \nimport { HELP_TEXT, VERSION, NO_ARGS} from './constants'\n\nvar getArgumentsFromCommandLine = function(){\n  // \"clArgs\": \"Command Line Arguments\"\n    var clArgs = []; \n    process.argv.forEach(function (val, index, array) {\n      clArgs.push(val);\n  });\n  return clArgs.slice(2); \n}\n\nvar showAndRemoveSpecialFlags = function(args, flags, text){\n  var showed = false; \n  for (var i = 0; i < flags.length; i++){\n    if (args.indexOf(flags[i]) != -1){\n      if (!showed) {\n       console.log(text); // help text and version text should never be written to file.\n       showed = true; \n      }\n      // removes the flag. \n      args.splice(args.indexOf(flags[i]), 1)\n    }\n  } \n  return args;\n} \n\n// using the switch fall-through here. \nvar parseFlags = function(argObj, args){\n  for (var i = 0; i < args.length; i++){\n    switch(args[i]){\n      case '-m':\n      case '-moduli':\n        if(typeof(args[i+1]) == 'number'){\n          argObj.firstModulus = args[i+1];\n        }\n        if(typeof(args[i+2]) == 'number'){\n          argObj.secondModulus = args[i+2];\n        }\n        break;\n      case '-i':\n      case '-input':\n        argObj.input = args[i+1]; \n        break; \n      case '-o':\n      case '-output':\n        argObj.output = args[i+1]; \n        break; \n      case '-t':\n      case '-terms':\n        argObj.fizzTerm = args[i+1];\n        argObj.buzzTerm = args[i+2];\n      default:\n      break;\n    }\n  }\n  return argObj; \n}\n\nvar processInput = function(){\n  const helpFlags = ['-h', 'h', 'help', '-help', '--help', '--h'];\n  const versionFlags = ['-v', 'v', '-version', '--version', '--v'];\n  var args = getArgumentsFromCommandLine();\n  if (args.length < 2){ \n    console.log(\"Warning: Not enough arguments provided from command line\") \n  }\n  args = showAndRemoveSpecialFlags(args, versionFlags, VERSION);\n  args = showAndRemoveSpecialFlags(args, helpFlags, HELP_TEXT);\n    // at this point, args should only contain the flags we're interested in.\n\n  var argumentObject = {\n    first: args[0], // required\n    last: args[1], // required\n    firstModulus: 3, // default, may be overwritten in parseFlags\n    secondModulus: 5, // default, may be overwritten\n    input: null,\n    output: null,\n    fizzTerm: \"Fizz\", // default.\n    buzzTerm: \"Buzz\", // default. \n  }\n\n  // modify the argument object with any special cases that the user has entered: \n  argumentObject = parseFlags(argumentObject, args); \n  // sanitize input.\n  argumentObject.first = Number(argumentObject.first);\n  argumentObject.last = Number(argumentObject.last);\n  argumentObject.firstModulus = Number(argumentObject.firstModulus);\n  argumentObject.secondModulus = Number(argumentObject.secondModulus); \n\n  return argumentObject; \n} \n\n\nexport { \n  getArgumentsFromCommandLine, \n  showAndRemoveSpecialFlags, \n  prepNumbers, \n  parseFlags, \n  processInput\n} \n","var fizzbuzzer = function (number, fizzer = 3, buzzer = 5, fizzOutput = \"Fizz\", buzzOutput = \"Buzz\") {\n    // Technically speaking, 0 % any number will return true, but we don't particularly think\n    // of 0 as being \"divisible\" by anything. This should default to \"0\"; \n    if (number == 0){\n        return 0;\n    } else if ((number % fizzer === 0) && (number % buzzer === 0)){\n        return \"\" + fizzOutput + buzzOutput + '!'\n    } else if (number % fizzer === 0) {\n        return (fizzOutput + \"!\")\n    } else if (number % buzzer === 0) {\n        return (buzzOutput + \"!\");\n    } else {\n        return number;\n    }\n}\n\nvar createFizzBuzz = function (start, end, fizzer = 3, buzzer = 5, fizzOutput = \"Fizz\", buzzOutput = \"Buzz\")  {\n    var output = []; \n    var incre = 1; \n    if (start > end) {\n      incre = -1;\n    }\n    var earlyBreak = false; \n\n    process.stdin.setRawMode(true);\n    process.stdin.resume();\n    process.stdin.on('keypress', function(key){\n      console.log(key);\n      if(key.name == 'q'){\n        earlyBreak = true\n      }\n    });\n\n\n    for (var i = start; (end >= start) ? (i <= end) : (i >= end) ; i = i + incre) {\n      console.log(\"i\", i)\n        output.push(fizzbuzzer(i, fizzer, buzzer, fizzOutput, buzzOutput));\n        // check to see if we've aborted via user input; \n        if(earlyBreak){\n          return { earlyBreak, output }; \n        }\n    }\n    return { earlyBreak, output }; ; \n}\n\nexport {\n    fizzbuzzer,\n    createFizzBuzz\n}\n","const VERSION = 'v1.0.0';\n\nconst HELP_TEXT = 'Help Text Goes Here'\n\nvar getArgumentsFromCommandLine = function(){\n  // \"clArgs\": \"Command Line Arguments\"\n    var clArgs = []; \n    process.argv.forEach(function (val, index, array) {\n      clArgs.push(val);\n  });\n  return clArgs.slice(2); \n}\n\nvar showAndRemoveSpecialFlags = function(args, flags, text){\n  var showed = false; \n  for (var i = 0; i < flags.length; i++){\n    if (args.indexOf(flags[i]) != -1){\n      if (!showed) {\n       console.log(text); // help text and version text should never be written to file.\n       showed = true; \n      }\n      // removes the flag. \n      args.splice(args.indexOf(flags[i]), 1)\n    }\n  } \n  return args;\n} \n\n// using the switch fall-through here. \nvar parseFlags = function(argObj, args){\n  for (var i = 0; i < args.length; i++){\n    switch(args[i]){\n      case '-m':\n      case '-moduli':\n        if(typeof(args[i+1]) == 'number'){\n          argObj.firstModulus = args[i+1];\n        }\n        if(typeof(args[i+2]) == 'number'){\n          argObj.secondModulus = args[i+2];\n        }\n        break;\n      case '-i':\n      case '-input':\n        argObj.input = args[i+1]; \n        break; \n      case '-o':\n      case '-output':\n        argObj.output = args[i+1]; \n        break; \n      case '-t':\n      case '-terms':\n        argObj.fizzTerm = args[i+1];\n        argObj.buzzTerm = args[i+2];\n      default:\n      break;\n    }\n  }\n  return argObj; \n}\n\nvar processInput = function(){\n  const helpFlags = ['-h', 'h', 'help', '-help', '--help', '--h'];\n  const versionFlags = ['-v', 'v', '-version', '--version', '--v'];\n  var args = getArgumentsFromCommandLine();\n  if (args.length < 2){ \n    console.log(\"Warning: Not enough arguments provided from command line\") \n  }\n  args = showAndRemoveSpecialFlags(args, versionFlags, VERSION);\n  args = showAndRemoveSpecialFlags(args, helpFlags, HELP_TEXT);\n    // at this point, args should only contain the flags we're interested in.\n\n  var argumentObject = {\n    first: args[0], // required\n    last: args[1], // required\n    firstModulus: 3, // default, may be overwritten in parseFlags\n    secondModulus: 5, // default, may be overwritten\n    input: null,\n    output: null,\n    fizzTerm: \"Fizz\", // default.\n    buzzTerm: \"Buzz\", // default. \n  }\n\n  // modify the argument object with any special cases that the user has entered: \n  argumentObject = parseFlags(argumentObject, args); \n  // sanitize input.\n  argumentObject.first = Number(argumentObject.first);\n  argumentObject.last = Number(argumentObject.last);\n  argumentObject.firstModulus = Number(argumentObject.firstModulus);\n  argumentObject.secondModulus = Number(argumentObject.secondModulus); \n\n  return argumentObject; \n}\n\nvar fizzbuzzer = function (number, fizzer = 3, buzzer = 5, fizzOutput = \"Fizz\", buzzOutput = \"Buzz\") {\n    // Technically speaking, 0 % any number will return true, but we don't particularly think\n    // of 0 as being \"divisible\" by anything. This should default to \"0\"; \n    if (number == 0){\n        return 0;\n    } else if ((number % fizzer === 0) && (number % buzzer === 0)){\n        return \"\" + fizzOutput + buzzOutput + '!'\n    } else if (number % fizzer === 0) {\n        return (fizzOutput + \"!\")\n    } else if (number % buzzer === 0) {\n        return (buzzOutput + \"!\");\n    } else {\n        return number;\n    }\n}\n\nvar createFizzBuzz = function (start, end, fizzer = 3, buzzer = 5, fizzOutput = \"Fizz\", buzzOutput = \"Buzz\")  {\n    var output = []; \n    var incre = 1; \n    if (start > end) {\n      incre = -1;\n    }\n    var earlyBreak = false; \n\n    process.stdin.setRawMode(true);\n    process.stdin.resume();\n    process.stdin.on('keypress', function(key){\n      console.log(key);\n      if(key.name == 'q'){\n        earlyBreak = true\n      }\n    });\n\n\n    for (var i = start; (end >= start) ? (i <= end) : (i >= end) ; i = i + incre) {\n      console.log(\"i\", i)\n        output.push(fizzbuzzer(i, fizzer, buzzer, fizzOutput, buzzOutput));\n        // check to see if we've aborted via user input; \n        if(earlyBreak){\n          return { earlyBreak, output }; \n        }\n    }\n    return { earlyBreak, output }; ; \n}\n\nexport { fizzbuzzer, createFizzBuzz, getArgumentsFromCommandLine, showAndRemoveSpecialFlags, parseFlags, processInput, HELP_TEXT, VERSION };"],"sourceRoot":"/source/"}